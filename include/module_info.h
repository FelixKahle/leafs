// Copyright 2023 Felix Kahle.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef FKL_MODULE_INFO_H
#define FKL_MODULE_INFO_H

#include <string>
#include <typeinfo>
#include <type_traits>

#include "module_interface.h"

namespace fkleafs
{
	/**
	 * Info about a module.
	 * Stores a identification hash that is unique for any given module
	 * and a string containing the name of the module.
	 */
	class ModuleInfo
	{
	private:
		/**
		 * Private constructor.
		 * Instances of the class are being generated by calling fkleafs::ModuleInfo::GetModuleInfo<ModuleType>()
		 */
		ModuleInfo()
			: m_module_name()
			, m_module_hash(-1)
		{}

	public:

		/**
		 * Returns a new instance of ModuleInfo.
		 * 
		 * @template param Module The module type to generate the info for.
		 * @return The module info for the given module type.
		 */
		template<typename Module>
		static inline ModuleInfo GetModuleInfo()
		{
			// Required that Module is derived from ModuleInterface.
			static_assert(std::is_base_of<ModuleInterface, Module>::value, "Any Module should be derived from ModuleInterface");

			// Use typeid to retrieve the info about the module.
			//
			// When applied to an expression of polymorphic type, 
			// evaluation of a typeid expression may involve runtime overhead 
			// (a virtual table lookup), otherwise typeid expression is resolved at compile time.
			// https://en.cppreference.com/w/cpp/language/typeid
			// 
			// There should be no runtime overhead here.
			const std::type_info& type_info = typeid(Module);

			ModuleInfo module_info;
			module_info.m_module_name = type_info.name();
			module_info.m_module_hash = type_info.hash_code();
			return module_info;
		}

		/**
		 * Getter for the name of the module.
		 *
		 * @return the name of the module.
		 */
		const std::string& ModuleName() const
		{
			return m_module_name;
		}

		/**
		 * Getter for the hash identifier of the module.
		 *
		 * @return the hash identifier.
		 */
		std::size_t ModuleHash() const
		{
			return m_module_hash;
		}

	public:
		/**
		 * Used to generate a hash from a ModuleInfo instance.
		 * May be used by hash tables.
		 */
		struct ModuleInfoHash
		{
			std::size_t operator()(const ModuleInfo& module_info) const
			{
				return module_info.ModuleHash();
			}
		};

		/**
		 * Used to compare two Module info instances. 
		 */
		struct ModuleInfoEqual
		{
			bool operator()(const ModuleInfo& lhs, const ModuleInfo& rhs) const
			{
				return lhs.ModuleHash() == rhs.ModuleHash();
			}
		};

	private:
		std::string m_module_name;
		std::size_t m_module_hash;
	};
}

#endif // !FKL_MODULE_INFO_H
